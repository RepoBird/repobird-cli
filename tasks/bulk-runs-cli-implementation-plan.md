# Bulk Runs CLI Implementation Plan

## Overview
This document outlines the implementation plan for adding bulk/batch run creation support to the RepoBird CLI and TUI. The implementation will support multiple configuration formats and provide an intuitive UI for managing multiple runs in parallel.

## 1. Configuration File Formats

### 1.1 Bulk JSON Format

#### Full Example (All Optional Fields)
```json
{
  "repository": "org/repo",  // OR "repoId": 123 (REQUIRED)
  "batchTitle": "Q1 Bug Fixes",  // Optional
  "source": "main",  // Optional, defaults to repo default
  "runType": "run",  // Optional, defaults to "run"
  "force": false,  // Optional, override duplicate detection
  "runs": [
    {
      "prompt": "Fix authentication bug",  // REQUIRED
      "title": "Fix auth issue",  // Optional
      "target": "fix/auth-bug",  // Optional, auto-generated if not provided
      "context": "Users can't login"  // Optional
    },
    {
      "prompt": "Add password reset",  // REQUIRED
      "title": "Password reset feature",  // Optional
      "target": "feature/password-reset",  // Optional
      "context": "Implement forgot password"  // Optional
    }
  ]
}

// Note: fileHash is generated by CLI/TUI when loading files, not part of config
```

#### Minimal Example (Required Fields Only)
```json
{
  "repository": "org/repo",
  "runs": [
    {"prompt": "Fix the login bug"},
    {"prompt": "Add password reset"},
    {"prompt": "Update dashboard"}
  ]
}
```

### 1.2 Bulk YAML Format

#### Full Example
```yaml
repository: org/repo  # OR repoId: 123 (REQUIRED)
batchTitle: Authentication Refactor  # Optional
source: main  # Optional
runType: run  # Optional
force: false  # Optional, override duplicate detection
runs:
  - prompt: |  # REQUIRED
      Fix the authentication bug where users cannot login
      with valid credentials
    title: Fix auth issue  # Optional
    target: fix/auth-bug  # Optional
    context: |  # Optional
      Error occurs after recent security update
      Check session handling
  
  - prompt: Add password reset functionality  # REQUIRED
    title: Password reset feature  # Optional
    target: feature/password-reset  # Optional
    context: Implement forgot password flow  # Optional
```

#### Minimal Example
```yaml
repository: org/repo
runs:
  - prompt: Fix the login bug
  - prompt: Add password reset
  - prompt: Update dashboard
```

### 1.3 Bulk Markdown Format
```markdown
---
repository: org/repo  # REQUIRED
batchTitle: Q1 Improvements  # Optional
source: main  # Optional
runType: run  # Optional
---

# Bulk Task Execution

## Run 1: Fix Authentication Bug
**Target**: fix/auth-bug  (Optional)

Fix the authentication bug where users cannot login with valid credentials.

### Context (Optional)
Error occurs after recent security update. Check session handling.

---

## Run 2: Password Reset Feature

Add password reset functionality with email verification.

---

## Run 3: Dashboard Update

Update the user dashboard with new metrics.
```

### 1.4 JSONL Format (JSON Lines)
```jsonl
{"repository": "org/repo", "prompt": "Fix auth bug", "title": "Auth fix", "target": "fix/auth"}
{"repository": "org/repo", "prompt": "Add password reset", "title": "Password reset", "target": "feature/reset"}
{"repository": "org/repo2", "prompt": "Update API", "title": "API update", "target": "update/api"}
```

## 2. CLI Command Structure

### 2.1 New Bulk Command
```bash
# Create bulk runs from a single bulk config file
repobird bulk bulk-runs.json
repobird bulk bulk-runs.yaml
repobird bulk bulk-runs.jsonl

# Create bulk from multiple single-run files
repobird bulk task1.json task2.json task3.yaml
repobird bulk tasks/*.json  # Glob pattern for multiple files

# Mix of single and bulk files (auto-detected)
repobird bulk single1.json single2.yaml bulk-config.json

# Interactive bulk mode
repobird bulk --interactive

# With options
repobird bulk runs.json --follow
repobird bulk tasks/*.yaml --dry-run
repobird bulk runs.jsonl --force  # Override duplicate detection
```

### 2.2 Enhanced Run Command
```bash
# Auto-detect bulk format
repobird run bulk-tasks.json  # Detects 'runs' array
repobird run *.yaml --bulk     # Process multiple files as bulk
```

## 3. New TUI Components

### 3.1 Bulk View (`internal/tui/views/bulk.go`)
```go
package views

import (
    tea "github.com/charmbracelet/bubbletea"
    "github.com/charmbracelet/lipgloss"
)

type BulkView struct {
    // Configuration
    repository      string
    repoID         int
    sourceBranch   string
    runType        string
    
    // Runs collection
    runs           []BulkRunItem
    selectedRun    int
    
    // UI state
    mode           BulkMode
    fileSelector   *BulkFileSelector
    runEditor      *RunEditor
    progressView   *BulkProgressView
    
    // Submission state
    submitting     bool
    batchID        string
    results        []BulkRunResult
}

type BulkMode int

const (
    ModeFileSelect BulkMode = iota
    ModeRunList
    ModeRunEdit
    ModeProgress
    ModeResults
)

type BulkRunItem struct {
    Prompt      string
    Title       string
    Target      string
    Context     string
    Selected    bool  // For multi-select
    Status      RunStatus
    Error       string
}
```

### 3.2 Bulk File Selector (`internal/tui/components/bulk_file_selector.go`)
```go
package components

type BulkFileSelector struct {
    files          []FileItem
    selected       map[string]bool  // Multi-select support
    filteredFiles  []FileItem
    filterInput    string
    mode           SelectMode
    previewContent map[string]string  // Cache previews
}

type SelectMode int

const (
    SingleSelect SelectMode = iota
    MultiSelect
    DirectorySelect
)

type FileItem struct {
    Path         string
    Name         string
    Type         FileType  // JSON, YAML, MD, JSONL
    Size         int64
    Modified     time.Time
    RunCount     int       // Number of runs in file
    IsDirectory  bool
}

func (bfs *BulkFileSelector) ToggleSelection(index int) {
    // Toggle selection for multi-select mode
}

func (bfs *BulkFileSelector) GetSelectedFiles() []string {
    // Return all selected files
}

func (bfs *BulkFileSelector) ParseSelectedFiles() ([]BulkRunItem, error) {
    // Parse all selected files into run items
}
```

### 3.3 Run Editor Component (`internal/tui/components/run_editor.go`)
```go
package components

type RunEditor struct {
    runs          []BulkRunItem
    currentIndex  int
    editMode      bool
    formFields    map[string]*FormField
}

func (re *RunEditor) AddRun() {
    // Add new run to collection
}

func (re *RunEditor) RemoveRun(index int) {
    // Remove run from collection
}

func (re *RunEditor) DuplicateRun(index int) {
    // Duplicate existing run
}

func (re *RunEditor) ReorderRuns(from, to int) {
    // Reorder runs in collection
}
```

### 3.4 Bulk Progress View (`internal/tui/components/bulk_progress.go`)
```go
package components

type BulkProgressView struct {
    batchID       string
    runs          []ProgressItem
    overallStatus BatchStatus
    startTime     time.Time
    pollInterval  time.Duration  // Polling interval for status updates
    lastPoll      time.Time
}

type ProgressItem struct {
    ID           int
    Title        string
    Status       RunStatus
    Progress     int  // 0-100
    Message      string
    StartTime    *time.Time
    EndTime      *time.Time
    Error        string
}

type BatchStatus struct {
    Total        int
    Queued       int
    Processing   int
    Completed    int
    Failed       int
}
```

## 4. File Format Parsing

### 4.1 Bulk Config Parser (`internal/utils/bulk_config.go`)
```go
package utils

type BulkConfig struct {
    Repository   string         `json:"repository" yaml:"repository"`
    RepoID      int            `json:"repoId" yaml:"repoId"`
    BatchTitle  string         `json:"batchTitle" yaml:"batchTitle"`
    Source      string         `json:"source" yaml:"source"`
    RunType     string         `json:"runType" yaml:"runType"`
    Force       bool           `json:"force" yaml:"force"`  // Override duplicate detection
    Runs        []BulkRunConfig `json:"runs" yaml:"runs"`
}

type BulkRunConfig struct {
    Prompt      string  `json:"prompt" yaml:"prompt"`        // REQUIRED
    Title       string  `json:"title" yaml:"title"`          // Optional
    Target      string  `json:"target" yaml:"target"`        // Optional
    Context     string  `json:"context" yaml:"context"`      // Optional
}

// BulkRunRequest is what gets sent to the API (includes generated fields)
type BulkRunRequest struct {
    BulkConfig
    // FileHash is generated by CLI/TUI for each run based on the config file
    RunHashes []string  // One hash per run, generated from file content
}

const MaxBulkBatchSize = 10  // Maximum runs per batch

// LoadBulkConfig loads bulk configuration from file(s)
func LoadBulkConfig(paths []string) (*BulkConfig, error) {
    if len(paths) == 0 {
        return nil, fmt.Errorf("no files specified")
    }
    
    if len(paths) == 1 {
        // Single file - could be bulk or single run config
        return ParseBulkConfig(paths[0])
    }
    
    // Multiple files - combine into bulk config
    return CreateBulkFromSingleConfigs(paths)
}

// CreateBulkFromSingleConfigs creates a bulk config from multiple single-run files
func CreateBulkFromSingleConfigs(paths []string) (*BulkConfig, error) {
    var runs []BulkRunConfig
    var repository string
    var repoID int
    
    for _, path := range paths {
        // Try to parse as single run config
        singleConfig, err := config.LoadConfig(path)
        if err != nil {
            // Try as bulk config
            bulkConfig, bulkErr := ParseBulkConfig(path)
            if bulkErr != nil {
                return nil, fmt.Errorf("failed to parse %s: %v", path, err)
            }
            // Add all runs from bulk config
            runs = append(runs, bulkConfig.Runs...)
            if repository == "" {
                repository = bulkConfig.Repository
                repoID = bulkConfig.RepoID
            }
        } else {
            // Convert single run to bulk run
            run := BulkRunConfig{
                Prompt:  singleConfig.Prompt,
                Title:   singleConfig.Title,
                Target:  singleConfig.Target,
                Context: singleConfig.Context,
            }
            runs = append(runs, run)
            
            // Use repository from first file if not set
            if repository == "" {
                repository = singleConfig.Repository
                repoID = singleConfig.RepoID
            }
        }
    }
    
    // Create final bulk config
    bulk := &BulkConfig{
        Repository: repository,
        RepoID:     repoID,
        Runs:       runs,
        BatchTitle: fmt.Sprintf("Batch of %d tasks", len(runs)),
    }
    
    return validateBulkConfig(bulk)
}

func ParseBulkConfig(path string) (*BulkConfig, error) {
    // Auto-detect if file is bulk or single config
    content, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    // Check if it has "runs" array (bulk) or just single run fields
    var test map[string]interface{}
    json.Unmarshal(content, &test)
    
    if _, hasBulk := test["runs"]; hasBulk {
        // It's a bulk config
        config, err := parseFile(path)
        if err != nil {
            return nil, err
        }
        return validateBulkConfig(config)
    }
    
    // It's a single config - convert to bulk
    singleConfig, err := config.LoadConfig(path)
    if err != nil {
        return nil, err
    }
    
    bulk := &BulkConfig{
        Repository: singleConfig.Repository,
        RepoID:     singleConfig.RepoID,
        Source:     singleConfig.Source,
        RunType:    singleConfig.RunType,
        Runs: []BulkRunConfig{{
            Prompt:  singleConfig.Prompt,
            Title:   singleConfig.Title,
            Target:  singleConfig.Target,
            Context: singleConfig.Context,
        }},
    }
    
    return validateBulkConfig(bulk)
}

func validateBulkConfig(config *BulkConfig) (*BulkConfig, error) {
    // Validate batch size
    if len(config.Runs) > MaxBulkBatchSize {
        return nil, fmt.Errorf("batch size exceeds maximum of %d runs (got %d)", 
            MaxBulkBatchSize, len(config.Runs))
    }
    
    // Validate required fields
    if config.Repository == "" && config.RepoID == 0 {
        return nil, fmt.Errorf("either repository or repoId is required")
    }
    
    // Validate each run has a prompt
    for i, run := range config.Runs {
        if run.Prompt == "" {
            return nil, fmt.Errorf("run %d is missing required prompt field", i+1)
        }
    }
    
    return config, nil
}
```

## 5. API Client Extensions

### 5.1 Bulk API Methods (`internal/api/client.go`)
```go
func (c *Client) CreateBulkRuns(req *BulkRunRequest) (*BulkRunResponse, error) {
    // POST /api/v1/runs/bulk
}

func (c *Client) GetBulkStatus(batchID string) (*BulkStatusResponse, error) {
    // GET /api/v1/runs/bulk/{batchId}
}

func (c *Client) CancelBulkRuns(batchID string) error {
    // DELETE /api/v1/runs/bulk/{batchId}
}

func (c *Client) PollBulkStatus(ctx context.Context, batchID string, interval time.Duration) (<-chan BulkStatusResponse, error) {
    // Poll for status updates at specified interval
}
```

### 5.2 DTO Extensions (`internal/api/dto/bulk_run.go`)
```go
package dto

type BulkRunRequest struct {
    RepositoryName string          `json:"repositoryName,omitempty"`
    RepoID        int             `json:"repoId,omitempty"`
    RunType       string          `json:"runType"`
    SourceBranch  string          `json:"sourceBranch"`
    Runs          []RunItem       `json:"runs"`
    Options       BulkOptions     `json:"options"`
}

type BulkRunResponse struct {
    BatchID  string              `json:"batchId"`
    Runs     []RunCreatedItem    `json:"runs"`
    Errors   []RunError          `json:"errors,omitempty"`
    Metadata BulkMetadata        `json:"metadata"`
}
```

## 6. TUI Navigation Flow

### 6.1 Main Dashboard Enhancement
```
Dashboard View
├── [b] Bulk Run      -> Opens Bulk View
├── [n] New Run       -> Opens Create View (single)
└── [t] TUI Settings  -> Settings
```

### 6.2 Bulk View Flow
```
Bulk View
├── File Selection Mode
│   ├── Single file select -> Parse & display runs
│   ├── Multi-file select  -> Merge & display runs
│   └── JSONL import       -> Stream parse & display
│
├── Run List Mode
│   ├── View all runs
│   ├── Edit individual run
│   ├── Add new run
│   ├── Remove run
│   ├── Reorder runs
│   └── Toggle run selection
│
├── Submission Mode
│   ├── Validate all runs
│   ├── Check duplicates
│   ├── Confirm submission
│   └── Handle force override
│
└── Progress Mode
    ├── Poll for status updates
    ├── Individual run progress
    ├── Overall batch progress
    └── Cancel batch option
```

## 7. Keyboard Shortcuts

### 7.1 Bulk View Shortcuts
```
File Selection:
- f: Activate FZF search
- Space: Toggle file selection (multi-select)
- Enter: Load selected files
- a: Select all
- n: Select none

Run List:
- j/k: Navigate runs
- Space: Toggle run selection
- Enter: Edit run
- a: Add new run
- d: Delete run
- D: Duplicate run
- m: Move run (reorder)

Global:
- Ctrl+S: Submit batch
- Ctrl+C: Cancel
- ?: Help
- q: Back/Quit
```

## 8. Duplicate Detection

### 8.1 Batch-Level Hash
```go
func CalculateBatchHash(config *BulkConfig) string {
    // Calculate hash for entire batch configuration
}

func CheckBatchDuplicates(hashes []string) (map[string]int, error) {
    // Check which runs are duplicates
    // Returns map of hash -> existing run ID
}
```

### 8.2 UI Duplicate Handling
```go
type DuplicatePrompt struct {
    Duplicates   []DuplicateInfo
    UserChoice   DuplicateAction
}

type DuplicateAction int

const (
    SkipDuplicates DuplicateAction = iota
    ForceAll
    SelectiveForce
    Cancel
)
```

## 9. Error Handling

### 9.1 Validation Errors
- Repository not found/disabled
- Quota exceeded
- Invalid configuration
- Branch validation failures

### 9.2 Partial Success Handling
```go
type PartialSuccessHandler struct {
    Successful []int
    Failed     []FailedRun
}

func (h *PartialSuccessHandler) Display() string {
    // Format partial success message
}

func (h *PartialSuccessHandler) ShouldRetry() bool {
    // Determine if retry is appropriate
}
```

## 10. Implementation Phases

### Phase 1: Core Infrastructure (Week 1)
- [ ] Create bulk config parser for JSON/YAML
- [ ] Implement BulkConfig model
- [ ] Add bulk API client methods
- [ ] Create basic bulk command

### Phase 2: TUI Components (Week 2)
- [ ] Implement BulkView
- [ ] Create BulkFileSelector with multi-select
- [ ] Build RunEditor component
- [ ] Add bulk navigation to dashboard

### Phase 3: Advanced Features (Week 3)
- [ ] Add JSONL support
- [ ] Implement Markdown bulk format
- [ ] Create BulkProgressView with polling
- [ ] Add efficient status polling mechanism

### Phase 4: Polish & Testing (Week 4)
- [ ] Duplicate detection and handling
- [ ] Error handling and recovery
- [ ] Comprehensive testing
- [ ] Documentation updates

## 11. Testing Strategy

### 11.1 Unit Tests
```go
// internal/utils/bulk_config_test.go
func TestParseBulkJSON(t *testing.T)
func TestParseBulkYAML(t *testing.T)
func TestParseJSONL(t *testing.T)
func TestMergeBulkConfigs(t *testing.T)

// internal/tui/views/bulk_test.go
func TestBulkViewNavigation(t *testing.T)
func TestBulkFileSelection(t *testing.T)
func TestRunEditing(t *testing.T)
```

### 11.2 Integration Tests
```go
func TestBulkRunSubmission(t *testing.T)
func TestPartialSuccessHandling(t *testing.T)
func TestDuplicateDetection(t *testing.T)
func TestStatusPolling(t *testing.T)
```

## 12. Documentation Updates

### 12.1 CLI Help Text
```
repobird bulk --help

Submit multiple runs in parallel from configuration files

Usage:
  repobird bulk [files...] [flags]

Examples:
  # Single bulk config file
  repobird bulk tasks.json
  
  # Multiple files merged
  repobird bulk auth.yaml payment.yaml user.json
  
  # JSONL format
  repobird bulk runs.jsonl
  
  # Interactive mode
  repobird bulk --interactive

Flags:
  -f, --follow         Follow batch progress
  -p, --parallel int   Max concurrent runs (default 5)
  --force             Override duplicate detection
  --dry-run          Validate without submitting
  -i, --interactive   Interactive bulk mode
```

### 12.2 User Guide Updates
- Add bulk runs section to configuration guide
- Create bulk runs tutorial
- Update TUI guide with bulk view navigation
- Add examples for each format

## 13. Configuration Examples

### 13.1 Multiple Single-Run Files

You can create a bulk batch from multiple single-run configuration files:

#### Single Run File 1 (`fix-auth.json`):
```json
{
  "repository": "org/repo",
  "prompt": "Fix authentication bug",
  "title": "Fix auth",
  "target": "fix/auth"
}
```

#### Single Run File 2 (`add-feature.yaml`):
```yaml
repository: org/repo
prompt: Add password reset feature
title: Password reset
target: feature/password-reset
```

#### Single Run File 3 (`update-ui.md`):
```markdown
---
repository: org/repo
prompt: Update dashboard UI
title: Dashboard update
---
Update the dashboard with new metrics
```

#### Command to Batch Them:
```bash
# Combines all three single-run files into one batch
repobird bulk fix-auth.json add-feature.yaml update-ui.md

# Or use glob pattern
repobird bulk tasks/*.json tasks/*.yaml
```

This automatically creates a temporary bulk configuration with all runs combined.

### 13.2 Repository-Wide Refactoring
```yaml
repository: acme/webapp
source: develop
runType: run
runs:
  - prompt: "Refactor authentication module for better security"
    title: "Refactor auth"
    target: "refactor/auth"
    
  - prompt: "Update payment processing to use new API"
    title: "Update payments"
    target: "refactor/payments"
    
  - prompt: "Migrate user management to TypeScript"
    title: "TypeScript migration"
    target: "refactor/typescript"
```

### 13.2 Multi-Repository Updates
```jsonl
{"repository": "org/frontend", "prompt": "Update to React 18", "title": "React 18 upgrade"}
{"repository": "org/backend", "prompt": "Update to Node 20", "title": "Node 20 upgrade"}
{"repository": "org/mobile", "prompt": "Update to React Native 0.72", "title": "RN upgrade"}
```

### 13.3 Issue-Based Tasks
```json
{
  "repository": "org/repo",
  "source": "main",
  "runs": [
    {
      "prompt": "Fix issue #123: Login timeout",
      "title": "Fix #123",
      "target": "fix/issue-123"
    },
    {
      "prompt": "Fix issue #124: Password validation",
      "title": "Fix #124",
      "target": "fix/issue-124"
    },
    {
      "prompt": "Implement feature #125: 2FA support",
      "title": "Feature #125",
      "target": "feature/issue-125"
    }
  ]
}
```

## 14. Performance Considerations

### 14.1 File Parsing
- Stream parse large JSONL files
- Lazy load file previews
- Cache parsed configurations

### 14.2 UI Responsiveness
- Virtualized lists for many runs
- Debounced search/filter
- Progressive loading of results

### 14.3 API Optimization
- Batch validation before submission
- Compress large requests
- Implement request retry with backoff

## 15. Future Enhancements

### 15.1 Templates
- Save bulk configurations as templates
- Template variables and substitution
- Template marketplace/sharing

### 15.2 Scheduling
- Schedule bulk runs for later
- Recurring bulk runs
- Time-based triggers

### 15.3 Dependencies
- Define dependencies between runs
- Sequential execution options
- Conditional execution based on results

### 15.4 Reporting
- Export bulk run results
- Generate summary reports
- Integration with CI/CD pipelines